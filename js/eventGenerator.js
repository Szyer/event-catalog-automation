const fs = require('fs');
const path = require('path');

// Function to format the event name
function formatEventName(eventType) {
  return eventType.split('.').map(word => word.charAt(0).toUpperCase() + word.slice(1)).join('');
}

// Function to create the Markdown content
function createMarkdown(event, producer, consumers) {
  const formattedName = formatEventName(event.type);
  const consumersList = Array.isArray(consumers) ? consumers.join('\n    - ') : consumers;
  return `---
name: "${formattedName}"
version: "${event.version}"
summary: |
  ${event.summary || "No summary provided."}
producers:
    - ${producer}
consumers:
    - ${consumersList}
owners:
    - digitalcare
---

### Details

${event.details || "No additional details provided."}

<NodeGraph title="Consumer / Producer Diagram" />

<Schema />`;
}

// Function to create the schema.json content
function createSchema(event) {
  return {
    type: "object",
    properties: {
      ...Object.keys(event.payload).reduce((acc, key) => {
        acc[key] = { type: typeof event.payload[key] };
        return acc;
      }, {})
    },
    required: Object.keys(event.payload)
  };
}

// Function to ensure all required properties are defined
function ensureDefined(event) {
  return {
    ...event,
    type: event.type || null,
    version: event.version || null,
    summary: event.summary || "No summary provided.",
    originId: event.originId || "Unknown Producer",
    details: event.details || "No additional details provided."
  };
}

// Function to normalize event type
function normalizeEventType(eventType) {
  return eventType.toLowerCase().replace(/\./g, '');
}

// Function to get the producer based on event type
function getProducer(eventType) {
  const normalizedEventType = normalizeEventType(eventType);
  for (const [service, pattern] of Object.entries(eventPatterns)) {
    const normalizedPattern = normalizeEventType(pattern);
    if (normalizedEventType.includes(normalizedPattern)) {
      return service;
    }
  }
  return "Unknown Producer";
}

// Function to read existing event data
function readExistingEventData(eventDir) {
  try {
    const indexPath = path.join(eventDir, 'index.md');
    const indexContent = fs.readFileSync(indexPath, 'utf8');
    const schemaPath = path.join(eventDir, 'schema.json');
    const schemaContent = JSON.parse(fs.readFileSync(schemaPath, 'utf8'));
    return { indexContent, schemaContent };
  } catch (error) {
    return null;
  }
}

// Function to compare event data
// Function to compare event data
function hasEventChanged(event, existingData, consumers) {
  if (!existingData) return true;
  const newMarkdownContent = createMarkdown(event, getProducer(event.type), consumers);
  if (existingData.indexContent.trim() !== newMarkdownContent.trim()) return true;
  const newSchemaContent = createSchema(event);
  return JSON.stringify(existingData.schemaContent) !== JSON.stringify(newSchemaContent);
}

// Function to update service patterns
function updateEventPatterns(eventNames, eventPatterns) {
  const updatedPatterns = { ...eventPatterns };
  eventNames.forEach(eventName => {
    const serviceName = formatEventName(eventName.replace(/\./g, ''));
    const pattern = new RegExp(`/${serviceName}/i`);
    if (!Object.values(updatedPatterns).some(existingPattern => existingPattern.source === pattern.source)) {
      updatedPatterns[serviceName] = pattern;
    }
  });
  return updatedPatterns;
}

// Function to get Consumer
function getConsumers(producer) {
  const consumerFilePath = path.join(__dirname, '../json/consumer.json');
  try {
    const consumerData = JSON.parse(fs.readFileSync(consumerFilePath, 'utf8'));
    const consumers = consumerData[producer] || ["digitalcare"]; // Default to digitalcare if mapping is not available
    return consumers;
  } catch (error) {
    console.error('Error reading consumer data:', error);
    return ["digitalcare"]; 
  }
}



const anonymizedData = JSON.parse(fs.readFileSync('../json/autogenerated/anonymized_events.json', 'utf8'));
const eventsDir = path.join(__dirname, '../uhx-catalog/events');
if (!fs.existsSync(eventsDir)) {
  fs.mkdirSync(eventsDir);
}

const eventPatternsFilePath = path.join(__dirname, '../json/eventPatterns.json');
let eventPatterns = JSON.parse(fs.readFileSync(eventPatternsFilePath, 'utf8'));

anonymizedData.aggregations.unique_event_types.buckets.forEach(bucket => {
  const event = ensureDefined(bucket.example_event.hits.hits[0]._source);
  event.name = formatEventName(event.type);
  const producer = getProducer(event.type);
  const consumers = getConsumers(producer); // Fetch consumers based on the producer
  const eventDir = path.join(eventsDir, event.name.replace(/\./g, '_'));
  const existingEventData = readExistingEventData(eventDir);
  if (hasEventChanged(event, existingEventData, consumers)) { // Pass consumers to hasEventChanged
    console.log(`Creating or updating event: ${event.name}`);
    if (!fs.existsSync(eventDir)) {
      fs.mkdirSync(eventDir);
    }
    const markdownContent = createMarkdown(event, producer, consumers); // Pass consumers to createMarkdown
    fs.writeFileSync(path.join(eventDir, 'index.md'), markdownContent, 'utf8');
    const schemaContent = createSchema(event);
    fs.writeFileSync(path.join(eventDir, 'schema.json'), JSON.stringify(schemaContent, null, 2), 'utf8');
  } else {
    console.log(`No changes detected for event: ${event.name}`);
  }
});


const newEventNames = anonymizedData.aggregations.unique_event_types.buckets.map(bucket => bucket.key);
eventPatterns = updateEventPatterns(newEventNames, eventPatterns);

console.log('Event directories and files generated successfully.');

module.exports = { getProducer };
